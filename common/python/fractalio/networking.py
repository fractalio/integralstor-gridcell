import socket, re
import fcntl
import struct
import command

def can_connect(hostname, port, timeout=0.05):

  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.settimeout(timeout)

  connected = True if s.connect_ex((hostname,port)) == 0 else False

  return connected

def is_ip(addr):
  test = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
  result = test.match(addr)
  if result:
    return True
  else:
    return False

def is_valid_ip(addr):
  if not is_ip(addr):
    return False
  match = re.search('([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)', addr)
  ip_tup = match.groups()
  for i in range(4):
    n = int(ip_tup[i])
    if n < 1 or n > 255:
      return False
  return True

def is_valid_hostname(hostname):
    if len(hostname) > 255:
        return False
    if hostname.endswith("."): # A single trailing dot is legal
        hostname = hostname[:-1] # strip exactly one dot from the right, if present
    disallowed = re.compile("[^A-Z\d-]", re.IGNORECASE)
    return all( # Split by labels and verify individually
        (label and len(label) <= 63 # length is within proper range
         and not label.startswith("-") and not label.endswith("-") # no bordering hyphens
         and not disallowed.search(label)) # contains only legal characters
        for label in hostname.split("."))

def is_valid_ip_or_hostname(addr):
  ret = False

  if is_ip(addr):
    if is_valid_ip(addr) :
      ret = True
  else:
    if is_valid_hostname(addr):
      ret = True

  return ret

def get_bonding_type(bondname):

  mode = -1
  try:
    with open('/etc/modprobe.d/bonding.conf', 'r') as f:
      for line in f:
        fields = line.strip().split()
        if fields and fields[0].lower() == 'options':
          r = re.match('[\s\S]*mode=([0-9])', line.strip())
          if r:
            mode_str = r.groups()[0]
            if mode_str:
              mode = int(mode_str)
  except Exception, e:
    print e
    return mode
  else:
    return mode

def set_bonding_type(bondname, bonding_type):
  if bonding_type not in [4, 6]:
    print "Unsupported bonding type : %d"%bonding_type
    return -1
  try:
    with open('/etc/modprobe.d/bonding.conf', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('alias %s bonding\n'%bondname)
      f.write('options %s mode=%d miimon=100 downdelay=200 updelay=200\n'%(bondname, bonding_type))
      f.flush()
    f.close()
  except Exception, e:
    print e
    return -1
  else:    
    return 0

def get_ip_info(ifname):
  ip_info = {}
  try:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    ip_info["ipaddr"] = socket.inet_ntoa(fcntl.ioctl( s.fileno(), 0x8915,  struct.pack('256s', ifname[:15]))[20:24])
    ip_info["netmask"] = socket.inet_ntoa(fcntl.ioctl(s.fileno(), 35099, struct.pack('256s', ifname))[20:24])
    """Read the default gateway directly from /proc."""
    with open("/proc/net/route") as fh:
      for line in fh:
        fields = line.strip().split()
        if fields[1] != '00000000' or not int(fields[3], 16) & 2:
          continue
        else:
          ip_info["default_gateway"] = socket.inet_ntoa(struct.pack("<L", int(fields[2], 16)))
          break
  except Exception, e:
    return None
  return ip_info

def set_bond_ip_info(d):
  #Only sets the bonding for bond0 to prevent other things from changing
  try:
    with open('/etc/sysconfig/network-scripts/ifcfg-bond0', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('DEVICE=bond0\n')
      f.write('IPADDR=%s\n'%d['ip'])
      f.write('NETMASK=%s\n'%d['netmask'])
      f.write('GATEWAY=%s\n'%d['default_gateway'])
      f.write('MTU=%s\n'%d['mtu'])
      f.write('NM_CONTROLLED=no\n')
      f.write('BOOTPROTO=none\n')
      f.write('ONBOOT=yes\n')
      f.write('USERCTL=no\n')
      f.flush()
    f.close()
    return 0
  except Exception, e:
    return -1
      
def set_hostname(hostname):
  try:
    with open('/etc/sysconfig/network', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      f.write('NETWORKING=yes\n')
      f.write('HOSTNAME=%s\n'%hostname)
      f.flush()
    f.close()
    r, rc = command.execute_with_rc('hostname %s'%hostname)
    if rc == 0:
      return 0
    else:
      print "Error setting hostname"
      return -1
  except Exception, e:
    return -1

def get_name_servers():
  name_server_list = []
  try :
    with open('/etc/resolv.conf', 'r') as f:
      for line in f:
        if line.startswith('#'):
          continue
        fields = line.strip().split()
        if fields and fields[0].lower() == 'nameserver':
          i = 1
          while i < len(fields):
            name_server_list.append(fields[i])
            i += 1
  except Exception, e:
    print e
    return None
  else:
    return name_server_list

def set_name_servers(ns_list):
  try:
    with open('/etc/resolv.conf', 'w') as f:
      f.write('#Generated by the IntegralStor script\n')
      for n in ns_list:
        f.write('nameserver %s\n'%n)
    f.flush()
    f.close()
    ret, rc = command.execute_with_rc('hostname %s'%hostname)
    if rc == 0:
      return 0
    else:
      return -1
  except Exception, e:
    return -1

def jumbo_frames_enabled(ifname):
  jumbo_frames = False
  try :
    with open('/etc/sysconfig/network-scripts/ifcfg-%s'%ifname, 'r') as f:
      for line in f:
        if line.startswith('#'):
          continue
        fields = line.strip().split('=')
        if fields[0].lower() == 'mtu':
          if len(fields) == 2:
            if int(fields[1]) == 9000:
              jumbo_frames = True
            else:
              jumbo_frames = False
  except Exception, e:
    return None
  else:
    return jumbo_frames

def generate_default_primary_named_conf(primary_ip, primary_netmask, secondary_ip):
  try :
    primary_cidr_netmask = get_subnet_in_cidr_format(primary_ip, primary_netmask)

    with open('/etc/named.conf', 'w') as f:
      f.write('// Generated by the IntegralStor script\n')
      f.write("options {\n")
      f.write(" listen-on port 53 { any; };\n")
      f.write(" listen-on-v6 port 53 { ::1; };\n")
      f.write(' directory 	"/var/named";\n')
      f.write(' dump-file 	"/var/named/data/cache_dump.db";\n')
      f.write(' statistics-file "/var/named/data/named_stats.txt";\n')
      f.write(' memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
      f.write(" allow-query     { localhost; any; };\n")
      f.write(" allow-transfer  { localhost; %s; };\n"%secondary_ip)
      f.write(" recursion no;\n")
      f.write("};\n")

      f.write("logging {\n")
      f.write(" channel default_debug {\n")
      f.write('   file "data/named.run";\n')
      f.write("   severity dynamic;\n")
      f.write(" };\n")
      f.write("};\n")


      f.write('zone "." IN {\n')
      f.write(" type hint;\n")
      f.write(' file "named.ca";\n')
      f.write("};\n")

      f.write('zone "fractalio.lan" IN {\n')
      f.write(" type master;\n")
      f.write(' file "fractalio.for";\n')
      f.write(" allow-update { localhost; %s; };\n"%primary_cidr_netmask)
      f.write("};\n")

      f.write('include "/etc/named.rfc1912.zones";\n')
      f.flush()
    f.close()
  except Exception, e:
    return -1
  else:
    return 0

def generate_default_secondary_named_conf(primary_ip, secondary_netmask, secondary_ip):
  try :
    secondary_cidr_netmask = get_subnet_in_cidr_format(primary_ip, secondary_netmask)

    with open('/etc/named.conf', 'w') as f:
      f.write('// Generated by the IntegralStor script\n')
      f.write('options {\n')
      f.write('  listen-on port 53 { any; };\n')
      f.write('  listen-on-v6 port 53 { ::1; };\n')
      f.write('  directory 	"/var/named";\n')
      f.write('  dump-file 	"/var/named/data/cache_dump.db";\n')
      f.write('  statistics-file "/var/named/data/named_stats.txt";\n')
      f.write('  memstatistics-file "/var/named/data/named_mem_stats.txt";\n')
      f.write('  allow-query     { localhost; %s; };\n'%secondary_cidr_netmask)
      f.write('  recursion no;\n')
      f.write('};\n')

      f.write('logging {\n')
      f.write('  channel default_debug {\n')
      f.write('    file "data/named.run";\n')
      f.write('    severity dynamic;\n')
      f.write('  };\n')
      f.write('};\n')


      f.write('zone "." IN {\n')
      f.write('  type hint;\n')
      f.write('  file "named.ca";\n')
      f.write('};\n')


      f.write('zone "fractalio.lan" IN {\n')
      f.write('  type slave;\n')
      f.write('  file "slaves/fractalio.for";\n')
      f.write('  masters { %s; };\n'%primary_ip)
      f.write('};\n')
      f.write('include "/etc/named.rfc1912.zones";\n')
      f.flush()
    f.close()
  except Exception, e:
    return -1
  else:
    return 0

def get_subnet_in_cidr_format(ip, subnet):
  #Given an IP and a subnet (as in 255.255..) string, returns the subnet info in CIDR format (as in 192.168.1.0/24)

  ipmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", ip)
  nmmatch = re.match(r"([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)", subnet)
  nms = ""
  network_addr = ""
  if ipmatch and nmmatch:
    ipl = ipmatch.groups()
    nml = nmmatch.groups()
    i=0
    while i < 4:
      binip =  bin(int(ipl[i]))
      #print binip
      binnm =  bin(int(nml[i]))
      nms += binnm[2:]
      #print binnm
      #print bin(int(ipl[i]) & int(nml[i]))
      network_addr += "%d"%(int(ipl[i]) & int(nml[i]))
      network_addr += '.'
      i+=1
  
  network_addr = network_addr[:(len(network_addr)-1)]
  count = 0
  #print nms
  for a in nms:
    if a == '1':
      count += 1
    else:
      break
  network_addr += '/%d'%count
  return network_addr
  
if __name__ == "__main__":
  print get_bonding_type('bond0')
  print get_ip_info('bond0')
  print get_name_servers()
  set_hostname('primary1')
  print set_bonding_type('bond0', 6)
  print jumbo_frames_enabled('bond0')
  print generate_default_primary_named_conf('10.1.1.4', '255.255.255.0', '10.1.1.5')



from integralstor_common import common
from integralstor_common import cifs as cifs_common
from integralstor_gridcell import local_users

import salt.client 
import os.path

def _generate_gridcell_specific_global_section(f, d):
  try:
    if not f:
      raise Exception('No file handle passed')
    conf_path, err = common.get_config_dir()
    if err:
      raise Exception(err)
    f.write("  server string = IntegralStor GRIDCell File server\n")
    f.write("  netbios name = %s\n"%d["netbios_name"].upper())
    f.write("  clustering=yes\n")
    f.write("  private dir=%s/lock\n"%conf_path)
  except Exception, e:
    return False, 'Error generating GRIDCell CIFS configuration - global section : %s'%str(e)
  else:
    return True, None

def _generate_gridcell_specific_share_body(f, vol_name):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("  vfs objects = glusterfs\n")
    f.write("  glusterfs:volfile_server = localhost\n")
    f.write("  glusterfs:volume = %s\n"%vol_name)
  except Exception, e:
    return False, 'Error generating GRIDCell CIFS configuration - share body section : %s'%str(e)
  else:
    return True, None

def _generate_share_section(f, share_name, vol_name, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method, extra_share_param_lines = None):
  try:
    if not f:
      raise Exception('No file handle passed')
    ret, err = cifs_common.generate_share_header(f, share_name)
    if err:
      raise Exception(err)
    ret, err = _generate_gridcell_specific_share_body(f, vol_name)
    if err:
      raise Exception(err)
    ret, err = cifs_common.generate_common_share_body(f, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method, extra_share_param_lines)
    if err:
      raise Exception(err)

  except Exception, e:
    return False, 'Error generating GRIDCell CIFS configuration file, shares section : %s'%str(e)
  else:
    return True, None
    

def generate_smb_conf():
  try:
    d, err = cifs_common.load_auth_settings()
    if err:
      raise Exception(err)
    smb_conf_path, err = common.get_smb_conf_path()
    if err:
      raise Exception(err)
    config_dir, err = common.get_config_dir()
    if err:
      raise Exception(err)

    #For customer specific or non configurable smb.conf lines
    extra_share_param_lines = None
    extra_global_param_lines = None
    if os.path.isfile('%s/customer_specific/extra_smb_share_params.conf'%config_dir):
      with open('%s/customer_specific/extra_smb_share_params.conf'%config_dir, 'r') as f1:
        extra_share_param_lines = f1.readlines()
    if os.path.isfile('%s/customer_specific/extra_smb_global_params.conf'%config_dir):
      with open('%s/customer_specific/extra_smb_global_params.conf'%config_dir, 'r') as f1:
        extra_global_param_lines = f1.readlines()
    #print extra_share_param_lines
    #print extra_global_param_lines

      
    with open("%s/smb.conf"%smb_conf_path, "w+") as f:
      ret, err = cifs_common.generate_global_header(f)
      if err:
        raise Exception(err)
      ret, err = _generate_gridcell_specific_global_section(f, d)
      if err:
        raise Exception(err)
      ret, err = cifs_common.generate_common_global_section(f, d, extra_global_param_lines)
      if err:
        raise Exception(err)
      shl, err = cifs_common.load_shares_list()
      if err:
        raise Exception(err)
      if shl:
        for share in shl:
          ul = []
          gl = []
          if not share["guest_ok"]:
            vul, err = cifs_common.load_valid_users_list(share["share_id"])
            if err:
              raise Exception(err)
            if vul:
              for vu in vul:
                if vu["grp"]:
                  gl.append(vu["name"])
                else:
                  ul.append(vu["name"])
          ret, err = _generate_share_section(f, share["name"], share["vol"], d["workgroup"], share["path"], share["read_only"], share["browseable"], share["guest_ok"], ul, gl, share["comment"], d["security"], extra_share_param_lines)
          if err:
            raise Exception(err)
    ret, errors = _reload_config()
    if errors:
      raise Exception(errors)
  except Exception, e:
    return False, 'Error generating CIFS configuration :%s'%str(e)
  else:
    return True, None

def _reload_config():
  try:
    errors = ''
    client = salt.client.LocalClient()
    r1 = client.cmd('*', 'cmd.run_all', ['/usr/bin/smbcontrol all reload-config'])
    if r1:
      for node, ret in r1.items():
        #print ret
        if ret["retcode"] != 0:
          errors += "Error reloading samba on GRIDCell %s "%node
    if errors:
      raise Exception(errors)
  except Exception, e:
    return False, 'Error reloading CIFS configuration: %s'%str(e)
  else:
    return True, None


  

def kinit(user, pswd, realm):
  try:
    errors = []
    client = salt.client.LocalClient()
    cmd_to_run = 'echo "%s" | kinit %s@%s'%(pswd, user, realm.upper())
    print 'Running %s'%cmd_to_run
    r1 = client.cmd('*', 'cmd.run_all', [cmd_to_run])
    if r1:
      for node, ret in r1.items():
        #print ret
        if ret["retcode"] != 0:
          e = "Error initiating kerberos on GRIDCell %s"%node
          if "stderr" in ret:
            e += " : %s"%ret["stderr"]
          errors.append(e)
          #print errors
    #print r1
  
    if errors:
      raise Exception(','.join(errors))
  except Exception, e:
    return False, 'Error initializing kerberos : %s'%str(e)
  else:
    return True, None


def net_ads_join(user, pswd, password_server):
  try:
    errors = []
    client = salt.client.LocalClient()
    cmd_to_run = "net ads join -S %s  -U %s%%%s"%(password_server, user, pswd)
    print 'Running %s'%cmd_to_run
    r1 = client.cmd('gridcell-pri.integralstor.lan', 'cmd.run_all', [cmd_to_run])
    print r1
    if r1:
      for node, ret in r1.items():
        #print ret
        if ret["retcode"] != 0:
          e = "Error joining AD on GRIDCell %s"%node
          if "stderr" in ret:
            e += " : %s"%ret["stderr"]
          errors.append(e)
          #print errors
    #print r1
    if errors:
      raise Exception(','.join(errors))
  except Exception, e:
    return False, 'Error joining AD : %s'%str(e)
  else:
    return True, None


def restart_samba_services():
  try:
    client = salt.client.LocalClient()
    rc = client.cmd('*', 'service.reload', ['smbd'] )
    #print rc
    rc = client.cmd('*', 'service.restart', ['winbind'] )
    #print rc
  except Exception, e:
    return False, 'Error restarting SMB services :%s'%str(e)
  else:
    return True, None


def _get_user_or_group_list(type):
  ret = None
  try:
    d, err = cifs_common.load_auth_settings()
    if err:
      raise Exception(err)
    if not d:
      raise Exception("Unspecified authentication method. Could not retrieve users")
    elif d["security"] == "users":
      if type and type == "users":
        l, err = local_users.get_local_users()
        if err:
          raise Exception(err)
        if l:
          ret = []
          for ld in l:
            ret.append(ld["userid"])
    elif d["security"] == "ads":
      if type and type == "users":
        ret, err =  cifs_common._get_ad_users_or_groups("users")
        if err:
          raise Exception(err)
      elif type and type == "groups":
        ret, err = cifs_common._get_ad_users_or_groups("groups")
        if err:
          raise Exception(err)
    else:
      raise Exception("Unsupported authentication method. Could not retrieve users/groups")
  except Exception, e:
    return None, 'Error retrieving user/group list:%s'%str(e)
  else:
    return ret, None


def get_user_list():
  ret = None
  try:
    ret, err = _get_user_or_group_list("users")
    if err:
      raise Exception(err)
  except Exception, e:
    return None, 'Error retrieving users list :%s'%str(e)
  else:
    return ret, None

def get_group_list():
  ret = None
  try:
    ret, err = _get_user_or_group_list("groups")
    if err:
      raise Exception(err)
  except Exception, e:
    return None, 'Error retrieving group list :%s'%str(e)
  else:
    return ret, None
  
def main():
  pass

if __name__ == "__main__":
  main()

'''
def _generate_global_section(f, d):
  try:
    if not f:
      raise Exception('No file handle passed')
    conf_path, err = common.get_config_path()
    if err:
      raise Exception(err)
    f.write("; This file has been programatically generated by the Integralstor system. Do not modify it manually!\n\n")
    f.write("[global]\n")
    f.write("  server string = IntegralStor GRIDCell File server\n")
    f.write("  clustering=yes\n")
    f.write("  private dir=%s/lock\n"%conf_path)
    f.write("  log file = /var/log/smblog.vfs\n")
    #f.write("  log level=5\n")
    f.write("  log level=1 acls:3 locking:3\n")
    f.write("  oplocks=yes\n")
    f.write("  ea support=yes\n")
    f.write("  level2 oplocks=yes\n")
    f.write("  posix locking=no\n")
    f.write("  load printers = no\n")
    f.write("  map to guest = bad user\n")
    f.write("  idmap config *:backend = tdb\n")
    f.write("  workgroup = %s\n"%d["workgroup"].upper())
    #f.write("  netbios name = %s\n"%d["netbios_name"].upper())
    if d["security"] == "ads":
      f.write("  security = ADS\n")
      f.write("  preferred master = no\n")
      f.write("  encrypt passwords = yes\n")
      f.write("  winbind enum users  = yes\n")
      f.write("  winbind enum groups = yes\n")
      f.write("  winbind use default domain = yes\n")
      f.write("  winbind nested groups = yes\n")
      f.write("  winbind separator = +\n")
      f.write("  local master = no\n")
      f.write("  domain master = no\n")
      f.write("  wins proxy = no\n")
      f.write("  dns proxy = no\n")
      #f.write("  idmap config *:range = %d-%d \n"%(d["id_map_max"]+1, d["id_map_max"]+10001))
      f.write("  winbind nss info = rfc2307\n")
      f.write("  winbind trusted domains only = no\n")
      f.write("  winbind refresh tickets = yes\n")
      f.write("  map untrusted to domain = Yes\n")
      f.write("  realm = %s\n"%d["realm"].upper())
      f.write("  idmap config %s:default = yes\n"%d["workgroup"].upper())
      f.write("  idmap config %s:backend = ad\n"%d["workgroup"].upper())
      f.write("  idmap config %s:schema_mode = %s\n"%(d["workgroup"].upper(), d["ad_schema_mode"]))
      #f.write("  idmap config %s:range = %d-%d\n"%(d["workgroup"].upper(), d["id_map_min"], d["id_map_max"]))
      f.write("  idmap config %s:range = 16777216-33554431\n")
      f.write("  idmap config %s:base_rid = 0\n"%d["workgroup"].upper())
  except Exception, e:
    return False, 'Error generating CIFS configuration - global section : %s'%str(e)
  else:
    return True, None


def _generate_share_section(f, share_name, vol_name, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("\n[%s]\n"%share_name)
    if comment:
      f.write("  comment = %s\n"%comment)
    f.write("  vfs objects = glusterfs\n")
    f.write("  glusterfs:volfile_server = localhost\n")
    f.write("  glusterfs:volume = %s\n"%vol_name)
    f.write("  path = %s\n"%path)
    f.write("  create mask = 0660\n")
    f.write("  kernel share modes = no\n")
    f.write("  directory mask = 0770\n")
    if read_only:
      t = "yes"
    else:
      t = "no"
    f.write("  read only = %s\n"%t)
    if user_list or group_list:
      s = "  valid users = "
      for user in user_list:
        if auth_method and auth_method == "users":
          s += " %s "%(user)
        else:
          s += " %s+%s "%(workgroup, user)
      for group in group_list:
        if auth_method and auth_method == "users":
          s += " @%s "%(group)
        else:
          s += " @%s+%s "%(workgroup, group)
      s += "\n"
      f.write(s)
  
    if browseable:
      t = "yes"
    else:
      t = "no"
    f.write("  browseable = %s\n"%t)
    if guest_ok:
      f.write("  guest ok = yes\n")
      #f.write("  guest account = %s\n"%guest_account)
  except Exception, e:
    return False, 'Error generating CIFS configuration file, shares section : %s'%str(e)
  else:
    return True, None

'''

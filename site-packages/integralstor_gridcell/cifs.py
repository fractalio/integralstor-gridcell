"""Routines that help in providing CIFS support for GRIDCell

This exports:
  _generate_gridcell_specific_global_section -- Internally used to generate the global section of smb.conf that is specific to gridcell
  _generate_gridcell_specific_share_body -- Internally used to generate the share body section of smb.conf that is specific to gridcell
  _generate_share_section -- Internally used to generate the complete share body section of smb.conf 
  generate_smb_conf -- Used to generate the complete smb.conf by calling on other functions to do parts of its work
  _reload_config -- Used to reload all SMB services on all nodes
  restart_samba_services -- Used to restart all SMB services on all nodes
  net_ads_join -- Used to join all nodes to the AD domain if configured
  kinit -- Used to initialize kerberos specific to the AD domain if configured
  _get_user_or_group_list -- Internally used to get the user or group list from either local or AD, whichever is currently configured.
  get_user_list -- Used to get the user list from either local or AD, whichever is currently configured.
  get_group -- Used to get the group list from either local or AD, whichever is currently configured.

"""


from integralstor_utils import config, command, db
from integralstor_utils import cifs as cifs_utils
from integralstor_gridcell import local_users

import salt.client
import os.path


def _generate_gridcell_specific_global_section(f, d):
    """Generate the global section of smb.conf that is specific to gridcell

    f -- The file handle for the smb.conf file
    d -- a dictionary which contains the relavant details needed to create that section

    Returns True on success and False otherwise
    """
    try:
        if not f:
            raise Exception('No file handle passed')

        conf_path, err = config.get_config_dir()
        if err:
            raise Exception(err)

        f.write("  server string = IntegralStor GRIDCell File server\n")
        f.write("  netbios name = %s\n" % d["netbios_name"].upper())
        # Commenting this out as we wont use CTDB for this release
        #f.write("  clustering=yes\n")
        f.write("  private dir=%s/lock\n" % conf_path)
    except Exception, e:
        return False, 'Error generating GRIDCell CIFS configuration - global section : %s' % str(e)
    else:
        return True, None


def _generate_local_share(f):
    try:
        ret, err = cifs_utils.generate_share_header(
            f, 'local_stor')
        if err:
            raise Exception(err)
        f.write("  path = /frzpool/local_storage\n")
        f.write("  comment = GRIDCell local storage share\n")
        f.write("  guest ok = yes\n")
        f.write("  read only = no\n")
        f.write("  create mask = 0660\n")
        f.write("  directory mask = 0770\n")
        f.write("  kernel share modes = no\n")
        f.write("  force group = integralstor\n")
        f.write("  browseable = no\n")

        ret, err = cifs_utils.generate_share_header(
            f, 'system_logs')
        if err:
            raise Exception(err)
        f.write("  path = /var/log\n")
        f.write("  comment = GRIDCell system var logs share\n")
        f.write("  guest ok = yes\n")
        f.write("  read only = yes\n")
        f.write("  browseable = no\n")
    except Exception, e:
        return False, 'Error generating local share : %s' % str(e)
    else:
        return True, None


def _generate_gridcell_specific_share_body(f, d):
    """Generate the share section of smb.conf that is specific to gridcell

    f -- The file handle for the smb.conf file
    d -- a dictionary which contains the relavant details needed to create that section

    Returns True on success and False otherwise
    """
    try:
        # print 'd is ', d
        if not f:
            raise Exception('No file handle passed')

        f.write("  vfs objects = glusterfs\n")
        f.write("  glusterfs:volfile_server = localhost\n")
        f.write("  glusterfs:volume = %s\n" % d['vol_name'])
        f.write("  force group = integralstor\n")
        if 'guest_ok' in d and d['guest_ok']:
            f.write("  guest ok = yes\n")
        else:
            if ('user_list' in d) or ('group_list'in d):
                s = "  valid users = "
                if 'user_list' in d:
                    for user in d['user_list']:
                        if d['auth_method'] == "users":
                            s += " %s " % user
                        else:
                            s += " %s+%s " % (d['workgroup'], user)
                if 'group_list' in d:
                    for group in d['group_list']:
                        if d['auth_method'] == "users":
                            s += " @%s " % (group)
                        else:
                            s += " @%s+%s " % (d['workgroup'], group)
            s += "\n"
            # print 's is ', s
            f.write(s)
    except Exception, e:
        return False, 'Error generating GRIDCell CIFS configuration - share body section : %s' % str(e)
    else:
        return True, None


def _generate_share_section(f, d, extra_share_param_lines=None):
    """Generate the complete share section of smb.conf 

    f -- The file handle for the smb.conf file
    d -- a dictionary which contains the relavant details needed to create that section
    extra_share_param_lines -- If a specific deployment needs specific share level parameters added, this contains a list of such directives

    Returns True on success and False otherwise
    """
    try:
        if not f:
            raise Exception('No file handle passed')

        ret, err = cifs_utils.generate_share_header(f, d['share_name'])
        if err:
            raise Exception(err)

        ret, err = _generate_gridcell_specific_share_body(f, d)
        if err:
            raise Exception(err)

        ret, err = cifs_utils.generate_common_share_body(f, d['workgroup'], d['path'], d['read_only'], d['browseable'],
                                                          d['comment'], extra_share_param_lines)
        if err:
            raise Exception(err)

    except Exception, e:
        return False, 'Error generating GRIDCell CIFS configuration file, shares section : %s' % str(e)
    else:
        return True, None


def generate_smb_conf():
    """Generate the complete of smb.conf that is specific to gridcell

    Returns True on success and False otherwise
    """
    try:
        d, err = cifs_utils.get_auth_settings()
        if err:
            raise Exception(err)

        smb_conf_path, err = config.get_smb_conf_path()
        if err:
            raise Exception(err)

        config_dir, err = config.get_config_dir()
        if err:
            raise Exception(err)

        # For customer specific or non configurable smb.conf lines
        extra_share_param_lines = None
        extra_global_param_lines = None
        if os.path.isfile('%s/customer_specific/extra_smb_share_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_share_params.conf' % config_dir, 'r') as f1:
                extra_share_param_lines = f1.readlines()
        if os.path.isfile('%s/customer_specific/extra_smb_global_params.conf' % config_dir):
            with open('%s/customer_specific/extra_smb_global_params.conf' % config_dir, 'r') as f1:
                extra_global_param_lines = f1.readlines()
        # print extra_share_param_lines
        # print extra_global_param_lines

        with open("%s/smb.conf" % smb_conf_path, "w+") as f:
            ret, err = cifs_utils.generate_global_header(f)
            if err:
                raise Exception(err)

            ret, err = _generate_gridcell_specific_global_section(f, d)
            if err:
                raise Exception(err)

            ret, err = cifs_utils.generate_common_global_section(
                f, d, extra_global_param_lines)
            if err:
                raise Exception(err)

            ret, err = _generate_local_share(f)
            if err:
                raise Exception(err)

            shl, err = cifs_utils.get_shares_list()
            if err:
                raise Exception(err)

            if shl:
                for share in shl:
                    ul = []
                    gl = []
                    if not share["guest_ok"]:
                        vul, err = get_valid_users_list(
                            share["share_id"])
                        if err:
                            raise Exception(err)
                        # print 'vul is ', vul
                        if vul:
                            for vu in vul:
                                if vu["grp"]:
                                    gl.append(vu["name"])
                                else:
                                    ul.append(vu["name"])
                    share_dict = {}
                    share_dict['share_name'] = share['name']
                    share_dict['vol_name'] = share['vol']
                    share_dict['workgroup'] = d['workgroup']
                    share_dict['path'] = share['path']
                    share_dict['read_only'] = share['read_only']
                    share_dict['browseable'] = share['browseable']
                    share_dict['guest_ok'] = share['guest_ok']
                    share_dict['comment'] = share['comment']
                    share_dict['auth_method'] = d['security']
                    share_dict['user_list'] = ul
                    share_dict['group_list'] = gl
                    ret, err = _generate_share_section(
                        f, share_dict, extra_share_param_lines)
                    if err:
                        raise Exception(err)

        ret, errors = _reload_config()
        if errors:
            raise Exception(errors)

    except Exception, e:
        return False, 'Error generating CIFS configuration :%s' % str(e)
    else:
        return True, None


def _reload_config():
    """Reload the config informationf for all samba processes

    Returns True on success and False otherwise
    """
    try:
        errors = ''
        client = salt.client.LocalClient()
        r1 = client.cmd('*', 'cmd.run_all',
                        ['/usr/bin/smbcontrol all reload-config'])
        if r1:
            for node, ret in r1.items():
                # print ret
                if ret["retcode"] != 0:
                    errors += "Error reloading Windows services on GRIDCell %s " % node
        if errors:
            raise Exception(errors)
        # restart winbind as a best-effort to prevent stale config; it could cause
        # problems from Microsoft side otherwise.
        r2 = client.cmd('*', 'cmd.run_all', ['service winbind restart'])
    except Exception, e:
        return False, 'Error reloading CIFS configuration: %s' % str(e)
    else:
        return True, None


def kinit(user, pswd, realm):
    """Initialized kerberos and get the initial ticket granting ticket

    user -- AD's admin username
    pswd -- AD's admin password
    realm -- AD realm

    Returns True on success and False otherwise
    """
    try:
        errors = []
        client = salt.client.LocalClient()
        cmd_to_run = 'echo "%s" | kinit %s@%s' % (pswd, user, realm.upper())
        print 'Running %s' % cmd_to_run
        r1 = client.cmd('*', 'cmd.run_all', [cmd_to_run])
        print r1
        if r1:
            for node, ret in r1.items():
                # print ret
                if ret["retcode"] != 0:
                    e = "Error initiating kerberos on GRIDCell %s" % node
                    if "stderr" in ret:
                        e += " : %s" % ret["stderr"]
                    errors.append(e)
                    # print errors
        if errors:
            raise Exception(','.join(errors))
    except Exception, e:
        return False, 'Error initializing kerberos : %s' % str(e)
    else:
        return True, None


def net_ads_join(user, pswd, password_server):
    """Join all gridcells to the AD realm

    user -- AD's admin username
    pswd -- AD's admin password
    password_server -- The AD server

    Returns True on success and False otherwise
    """
    try:
        # print 'aaa'
        errors = []
        client = salt.client.LocalClient()
        #cmd_to_run = "net ads join -S %s  -U %s%%%s"%(password_server, user, pswd)
        cmd_to_run = "net ads join  -U %s%%%s" % (user, pswd)
        print 'Running %s' % cmd_to_run
        output, err = command.get_command_output(cmd_to_run)
        print output, err
        if err:
            raise Exception(err)
        '''
    r1 = client.cmd('gridcell-pri.integralstor.lan', 'cmd.run_all', [cmd_to_run])
    #print r1
    if r1:
      for node, ret in r1.items():
        print ret
        if ret["retcode"] != 0:
          e = "Error joining AD on GRIDCell %s"%node
          if "stderr" in ret:
            e += " : %s"%ret["stderr"]
          errors.append(e)
          #print errors
    #print r1
    if errors:
      raise Exception(','.join(errors))
    '''
    except Exception, e:
        return False, 'Error joining AD : %s' % str(e)
    else:
        return True, None


def restart_samba_services():
    """Restart samba and winbind 

    Returns True on success and False otherwise
    """
    try:
        client = salt.client.LocalClient()
        rc = client.cmd('*', 'service.reload', ['smbd'])
        # print rc
        rc = client.cmd('*', 'service.restart', ['winbind'])
        # print rc
    except Exception, e:
        return False, 'Error restarting SMB services :%s' % str(e)
    else:
        return True, None

def get_valid_users_list(share_id):
    """Get the list of users from the db who have access to a share. """
    l = None
    try:
        db_path, err = config.get_db_path()
        if err:
            raise Exception(err)
        l, err = db.get_multiple_rows(
            db_path, 'select * from samba_valid_users where share_id = %s' % share_id)
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error loading valid users list : %s' % str(e)
    else:
        return l, None

def _get_user_or_group_list(type):
    """Depending on the type of auth currently configured, retrieve either the user list of group list 

    type -- either 'users' or 'groups' tells us which info is needed.

    Returns True on success and False otherwise
    """
    ret = None
    try:
        d, err = cifs_utils.get_auth_settings()
        if err:
            raise Exception(err)
        if not d:
            raise Exception(
                "Unspecified authentication method. Could not retrieve users")
        elif d["security"] == "users":
            if type and type == "users":
                l, err = local_users.get_local_users()
                if err:
                    raise Exception(err)
                if l:
                    ret = []
                    for ld in l:
                        ret.append(ld["userid"])
        elif d["security"] == "ads":
            if type and type == "users":
                ret, err = cifs_utils.get_ad_users_or_groups("users")
                if err:
                    raise Exception(err)
            elif type and type == "groups":
                ret, err = cifs_utils.get_ad_users_or_groups("groups")
                if err:
                    raise Exception(err)
        else:
            raise Exception(
                "Unsupported authentication method. Could not retrieve users/groups")
    except Exception, e:
        return None, 'Error retrieving user/group list:%s' % str(e)
    else:
        return ret, None


def get_user_list():
    """Depending on the type of auth currently configured, retrieve user list from that source

    Uses _get_user_or_group_list to get its info
    Returns True on success and False otherwise
    """
    ret = None
    try:
        ret, err = _get_user_or_group_list("users")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving users list :%s' % str(e)
    else:
        return ret, None


def get_group_list():
    """Depending on the type of auth currently configured, retrieve group list from that source

    Uses _get_user_or_group_list to get its info
    Returns True on success and False otherwise
    """
    ret = None
    try:
        ret, err = _get_user_or_group_list("groups")
        if err:
            raise Exception(err)
    except Exception, e:
        return None, 'Error retrieving group list :%s' % str(e)
    else:
        return ret, None


def main():
    print _reload_config()
    pass


if __name__ == "__main__":
    main()

'''
def _generate_global_section(f, d):
  try:
    if not f:
      raise Exception('No file handle passed')
    conf_path, err = config.get_config_path()
    if err:
      raise Exception(err)
    f.write("; This file has been programatically generated by the Integralstor system. Do not modify it manually!\n\n")
    f.write("[global]\n")
    f.write("  server string = IntegralStor GRIDCell File server\n")
    f.write("  clustering=yes\n")
    f.write("  private dir=%s/lock\n"%conf_path)
    f.write("  log file = /var/log/smblog.vfs\n")
    #f.write("  log level=5\n")
    f.write("  log level=1 acls:3 locking:3\n")
    f.write("  oplocks=yes\n")
    f.write("  ea support=yes\n")
    f.write("  level2 oplocks=yes\n")
    f.write("  posix locking=no\n")
    f.write("  load printers = no\n")
    f.write("  map to guest = bad user\n")
    f.write("  idmap config *:backend = tdb\n")
    f.write("  workgroup = %s\n"%d["workgroup"].upper())
    #f.write("  netbios name = %s\n"%d["netbios_name"].upper())
    if d["security"] == "ads":
      f.write("  security = ADS\n")
      f.write("  preferred master = no\n")
      f.write("  encrypt passwords = yes\n")
      f.write("  winbind enum users  = yes\n")
      f.write("  winbind enum groups = yes\n")
      f.write("  winbind use default domain = yes\n")
      f.write("  winbind nested groups = yes\n")
      f.write("  winbind separator = +\n")
      f.write("  local master = no\n")
      f.write("  domain master = no\n")
      f.write("  wins proxy = no\n")
      f.write("  dns proxy = no\n")
      #f.write("  idmap config *:range = %d-%d \n"%(d["id_map_max"]+1, d["id_map_max"]+10001))
      f.write("  winbind nss info = rfc2307\n")
      f.write("  winbind trusted domains only = no\n")
      f.write("  winbind refresh tickets = yes\n")
      f.write("  map untrusted to domain = Yes\n")
      f.write("  realm = %s\n"%d["realm"].upper())
      f.write("  idmap config %s:default = yes\n"%d["workgroup"].upper())
      f.write("  idmap config %s:backend = ad\n"%d["workgroup"].upper())
      f.write("  idmap config %s:schema_mode = %s\n"%(d["workgroup"].upper(), d["ad_schema_mode"]))
      #f.write("  idmap config %s:range = %d-%d\n"%(d["workgroup"].upper(), d["id_map_min"], d["id_map_max"]))
      f.write("  idmap config %s:range = 16777216-33554431\n")
      f.write("  idmap config %s:base_rid = 0\n"%d["workgroup"].upper())
  except Exception, e:
    return False, 'Error generating CIFS configuration - global section : %s'%str(e)
  else:
    return True, None


def _generate_share_section(f, share_name, vol_name, workgroup, path, read_only, browseable, guest_ok, user_list, group_list, comment, auth_method):
  try:
    if not f:
      raise Exception('No file handle passed')
    f.write("\n[%s]\n"%share_name)
    if comment:
      f.write("  comment = %s\n"%comment)
    f.write("  vfs objects = glusterfs\n")
    f.write("  glusterfs:volfile_server = localhost\n")
    f.write("  glusterfs:volume = %s\n"%vol_name)
    f.write("  path = %s\n"%path)
    f.write("  create mask = 0660\n")
    f.write("  kernel share modes = no\n")
    f.write("  directory mask = 0770\n")
    if read_only:
      t = "yes"
    else:
      t = "no"
    f.write("  read only = %s\n"%t)
    if user_list or group_list:
      s = "  valid users = "
      for user in user_list:
        if auth_method and auth_method == "users":
          s += " %s "%(user)
        else:
          s += " %s+%s "%(workgroup, user)
      for group in group_list:
        if auth_method and auth_method == "users":
          s += " @%s "%(group)
        else:
          s += " @%s+%s "%(workgroup, group)
      s += "\n"
      f.write(s)
  
    if browseable:
      t = "yes"
    else:
      t = "no"
    f.write("  browseable = %s\n"%t)
    if guest_ok:
      f.write("  guest ok = yes\n")
      #f.write("  guest account = %s\n"%guest_account)
  except Exception, e:
    return False, 'Error generating CIFS configuration file, shares section : %s'%str(e)
  else:
    return True, None

'''

# vim: tabstop=8 softtabstop=0 expandtab ai shiftwidth=4 smarttab
